<# Exports top level folder sizes for the Volumes included in the specified volume list.
Uses the Edge Appliance Data API to provide the list of top level folders within the volume.
Assumes each specified volume has a share at the root level of the volume and the 'Sync and Mobile Access'
share-level Advanced Setting is enabled (needed for the Data API) for each of these shares. #>

#populate NMC hostname or IP address
$nmcHostname = "insertNMChostname"

<# NMC authentication: Username for AD accounts supports both UPN (user@domain.com) and DOMAIN\\samaccountname formats (two backslashes required).
Nasuni Native user accounts are also supported. #>
$nmcUsername = "username@domain.com"
$nmcPassword = 'password'

<# Data API authentication: Username for AD accounts supports both UPN (user@domain.com) and DOMAIN\samaccountname formats (one backslash required).
Nasuni Native user accounts are also supported. The account used for the data API must have the ability to login/access the
data using the SMB protocol #>
$dataUsername = 'username@domain.com'
$dataPassword = 'password'

#Path to volume list - one volume name per line
$volumeListPath = "c:\nasuni\volumelist.txt"

#Path for CSV report output
$reportFile = "c:\nasuni\FolderSize.csv"

#Add this suffix to the NEA description to get a hostname for the data API. Enter your domain suffix here.
$domainSuffix = "domain.com"

#output for data API Tokens CSV file (generated by the script)
$dataApiTokenFile = "c:\nasuni\dataApiTokens.csv"

#Number of Volumes and Shares to query
$limit = 1000

#end variables

#combine NMC credentials for token request
$nmcCredentials = '{"username":"' + $nmcUsername + '","password":"' + $nmcPassword + '"}'

#initialize csv output file
$csvHeader = "volume_name,volume_guid,filer_name,filer_serial_number,path,size"
Out-File -FilePath $reportFile -InputObject $csvHeader -Encoding UTF8
write-host ("Exporting Top Level Folder Size Information to: " + $reportFile)

#set device ID and type for Data API authentication - should not need to change
$deviceID = "device01"
$deviceType = "linux"
 
#Build connection headers
# Allow untrusted SSL certs
if ($PSVersionTable.PSEdition -eq 'Core') #PowerShell Core
{
	if ($PSDefaultParameterValues.Contains('Invoke-RestMethod:SkipCertificateCheck')) {}
	else {
		$PSDefaultParameterValues.Add('Invoke-RestMethod:SkipCertificateCheck', $true)
	}
}
else #other versions of PowerShell
{if ("TrustAllCertsPolicy" -as [type]) {} else {		
	
Add-Type -TypeDefinition @"
using System.Net;
using System.Security.Cryptography.X509Certificates;
public class TrustAllCertsPolicy : ICertificatePolicy {
	public bool CheckValidationResult(
		ServicePoint srvPoint, X509Certificate certificate,
		WebRequest request, int certificateProblem) {
		return true;
	}
}
"@
[System.Net.ServicePointManager]::CertificatePolicy = New-Object -TypeName TrustAllCertsPolicy

#set the correct TLS Type
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
 } }
 
#build JSON headers
$nmcHeaders = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
$nmcHeaders.Add("Accept", 'application/json')
$nmcHeaders.Add("Content-Type", 'application/json')

#construct Uri
$url="https://"+$nmcHostname+"/api/v1.1/auth/login/"
 
#Use credentials to request and store a session token from NMC for later use
$result = Invoke-RestMethod -Uri $url -Method Post -Headers $nmcHeaders -Body $nmcCredentials
$token = $result.token
$nmcHeaders.Add("Authorization","Token " + $token)

#List Volumes using the NMC API
$nmcGetVolumesUrl="https://"+$nmcHostname+"/api/v1.2/volumes/?limit="+$limit+"&offset=0"
$nmcGetVolumes = Invoke-RestMethod -Uri $nmcGetVolumesUrl -Method Get -Headers $nmcHeaders

#Connect to the List all shares for filer NMC API endpoint
$nmcGetSharesUrl="https://"+$nmcHostname+"/api/v1.2/volumes/filers/shares/?limit=" + $limit+ "&offset=0"
$FormatEnumerationLimit=-1
$nmcGetShares = Invoke-RestMethod -Uri $nmcGetSharesUrl -Method Get -Headers $nmcHeaders

#List filers using the NMC API so we can find the filer's hostname
$nmcFilerInfoUrl="https://"+$nmcHostname+"/api/v1.2/filers/?limit="+$limit+"&offset=0"
$nmcGetFilerInfo = Invoke-RestMethod -Uri $nmcFilerInfoUrl -Method Get -Headers $nmcHeaders

#read the contents of the volume list file into a variable
$volumeList = Get-Content $volumeListPath | Select-Object | ConvertFrom-Csv -header "name"

#create an array to hold the NEA hostname list
$neaHostnames = @()

#get hostnames for all of the NEA volume owners
ForEach ($volume in $volumeList) {
    #get the volume name from the line in the file
    $volumeName = $volume.name

    #Use the volume name to find volume info
    $volume = $nmcGetVolumes.items | Where-Object {$_.name -eq $volumeName}  
    $volumeGuid =  $volume.guid
    $volumeFilerSerial = $volume.filer_serial_number

    #now find the filer's hostname so we can use it for the data api connection
    $filerInfo = $nmcGetFilerInfo.items | Where-Object {($_.serial_number -eq $volumeFilerSerial)}

    #combine the filer description with the domain suffix to get the hostname
    $neaHostnames +=  $filerInfo.description + "." + $domainSuffix
}

#Start getting Data API tokens
 #build Form values for Data API authentication
 $Form = [ordered]@{
    username = $dataUsername
    password = $dataPassword
    device_id = $deviceID
    device_type = $deviceType
}

#Initialize CSV token file
$csvHeader = "dataHostname,dataToken"
Out-File -FilePath $dataApiTokenFile -InputObject $csvHeader -Encoding UTF8

#get data API tokens for all the Volume Owners
$uniqueNeaHostNames = $neaHostNames | Get-Unique
ForEach ($dataHostName in $uniqueNeaHostNames) {
    #login the Data API and get token

    #construct Uri for Data API login
    $dataLoginUrl="https://"+$dataHostName+"/mobileapi/1/auth/login"

    #Use body to request and store the secret key from the Data API for later use
    $response = Invoke-WebRequest -Uri $dataLoginUrl -Method Post -Form $Form -SkipCertificateCheck
    $xSecretKey = $response.headers.'X-Secret-Key'
    $pair = "$($deviceID):$($xSecretKey)"
    $encodedCreds = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes($pair))
    
    #Write the token to the data API token file
    $datastring =  "$dataHostname,$encodedCreds"
    Out-File -FilePath $dataApiTokenFile -InputObject $datastring -Encoding UTF8 -append

}

#read the contents of the token CSV into variables
$dataTokens = Get-Content $dataApiTokenFile | Select-Object -Skip 1 | ConvertFrom-Csv -header "dataHostname","dataToken"


#Begin processing each volume to find the top level folder sizes
ForEach ($volume in $volumeList) {
    #get the volume name from the line in the file
    $volumeName = $volume.name

    #Use the volume name to find volume info
    $volume = $nmcGetVolumes.items | Where-Object {$_.name -eq $volumeName}  
    $volumeGuid =  $volume.guid
    $volumeFilerSerial = $volume.filer_serial_number
    #find the corresponding share - must match volume guid, filer serial number, path must be root, and the share must be mobile enabled
    $share = $nmcGetShares.items | Where-Object {($_.volume_guid -eq $volumeGuid) -and ($_.filer_serial_number -eq $volumeFilerSerial) -and ($_.path -eq "\") -and ($_.mobile -eq 'True') }

    #now find the filer's hostname so we can use it for the data api connection
    $filerInfo = $nmcGetFilerInfo.items | Where-Object {($_.serial_number -eq $volumeFilerSerial)}
    $filerName = $filerInfo.description

    #combine the filer description with the domain suffix to get the hostname
    $dataHostname =  $filerInfo.description + "." + $domainSuffix
   
    #get the corresponding data API token from the file
    $encodedCredsFromFile = $dataTokens | Where-Object {($_.dataHostname -eq $dataHostname)}

    $basicAuthValue = "Basic $($encodedCredsFromFile.dataToken)"
    $dataHeaders = @{
        Authorization = $basicAuthValue
    }

    #add the rest of the logic for top level folders
    #build path for getting share properties using the data API, including the top level folder name
    $dataGetShareUri = "https://"+$dataHostname+"/mobileapi/1/fs/" + $share.name + "/"
    #get the individual share information using the data API
    $dataGetShare = Invoke-RestMethod -Uri $dataGetShareUri -Method Get -Headers $dataHeaders -SkipCertificateCheck -SkipHttpErrorCheck
    
    #loop through the results to get a listing of top level folders
    foreach ($dataShare in $dataGetShare.items){
        #Only include folders in the comparison
        if ($dataShare.type -eq "directory") {
        $dataFolder = $dataShare.name
        
            #now we need to loop through the folders to get their size using the NMC API

            #Build the URL for the endpoints
            $nmcPathInfoURL="https://"+$nmcHostname+"/api/v1.1/volumes/" + $volumeGuid + "/filers/" + "$volumeFilerSerial" + "/path" + '/' + $dataFolder
            write-output $nmcPathInfoURL

            #Refresh Stats on the supplied path - calling as a variable to suppress output
            $nmcPathRefresh=Invoke-RestMethod -Uri $nmcPathInfoURL -Method POST -Headers $nmcHeaders
            
            #sleep to allow time for the refresh to complete
            Start-Sleep -s 5
            
            #Get Path Info
            $nmcGetPathInfo = Invoke-RestMethod -Uri $nmcPathInfoURL -Method Get -Headers $nmcHeaders
            $reportVolumeGuid = $nmcGetPathInfo.volume_guid
            $reportFilerSerial = $nmcGetPathInfo.filer_serial_number
            $reportPath = $nmcGetPathInfo.Path
            $reportSize = $nmcGetPathInfo.size

            #write folder size information to the CSV
            $datastring = "$volumeName,$reportVolumeGuid,$filerName,$reportFilerSerial,$reportPath,$reportSize"
            Out-File -FilePath $reportFile -InputObject $datastring -Encoding UTF8 -append
        }
    }
}

